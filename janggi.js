    class JanggiGame {
    constructor() {
        // Ïû•Í∏∞ÌåêÏùÄ 10Ìñâ 9Ïó¥
        this.board = [];
        this.rows = 10;
        this.cols = 9;

        // Ï¥àÎÇòÎùºÍ∞Ä Î®ºÏ†Ä ÏãúÏûë
        this.currentPlayer = 'cho';
        this.selectedSquare = null;
        this.gameStarted = false;
        this.capturedPieces = { cho: [], han: [] };

        // ÌÉÄÏù¥Î®∏ ÏÜçÏÑ±
        this.turnTimeLimit = 40; 
        this.currentTurnTime = this.turnTimeLimit;
        this.timerInterval = null;

        // Ïò®ÎùºÏù∏ Í≤åÏûÑ ÏÜçÏÑ±
        this.gameCode = null;
        this.isOnlineGame = false;
        this.isGameInProgress = false;
        this.isRoomHost = false; // Ï¥à(Ê•ö)
        this.isRoomGuest = false; // Ìïú(Êº¢)
        this.isMovePending = false; 

        // ÌîåÎ†àÏù¥Ïñ¥ Ïù¥Î¶Ñ
        this.hostPlayerName = '';
        this.guestPlayerName = '';

        // Firebase Ïã§ÏãúÍ∞Ñ ÌÜµÏã†
        this.database = null;
        this.playerId = this.generatePlayerId();
        this.gameRef = null;
        this.listeners = [];
        
        // Îã§ÌÅ¨Î™®Îìú ÏÉÅÌÉú
        this.isDarkMode = localStorage.getItem('darkMode') === 'true';

        // Ïû•Í∏∞ Í∏∞Î¨º (Unicode)
        this.pieces = {
            cho: { // Ï¥à (ÎÖπÏÉâ/ÌååÎûÄÏÉâ)
                king: 'Ê•ö', chariot: 'Ëªä', cannon: 'ÂåÖ', horse: 'È¶¨', elephant: 'Ë±°', guard: 'Â£´', soldier: 'Âçí'
            },
            han: { // Ìïú (Îπ®Í∞ÑÏÉâ)
                king: 'Êº¢', chariot: 'Ëªä', cannon: 'ÂåÖ', horse: 'È¶¨', elephant: 'Ë±°', guard: 'Â£´', soldier: 'ÂÖµ'
            }
        };

        console.log('üî• Janggi Game Initialization Started');
        console.log('üÜî Player ID:', this.playerId);

        this.initializeEventListeners();
        this.waitForFirebase();
    }

    initializeEventListeners() {
        document.getElementById('startGameBtn').addEventListener('click', () => this.startGame());
        document.getElementById('resetBtn').addEventListener('click', () => this.resetGameOnline());
        document.getElementById('backToMenuBtn').addEventListener('click', () => this.backToMenu());
        document.getElementById('copyCodeBtn').addEventListener('click', () => this.copyGameCode());
        document.getElementById('startGameBtnInRoom').addEventListener('click', () => this.startActualGame());
        document.getElementById('joinRoomBtn').addEventListener('click', () => this.joinRoom());
        document.getElementById('roomCodeInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') this.joinRoom();
        });
        
        document.getElementById('themeToggle').addEventListener('click', () => this.toggleTheme());
        document.getElementById('roomCodeInput').addEventListener('input', (e) => {
            e.target.value = e.target.value.replace(/[^0-9]/g, '');
        });
    }

    waitForFirebase() {
        if (window.firebaseReady && window.database) {
            this.database = window.database;
            console.log('üî• Firebase Connection Complete');
        } else {
            console.log('‚è≥ Waiting for Firebase to load...');
            document.addEventListener('firebaseReady', () => {
                this.database = window.database;
                console.log('üî• Firebase Connection Complete (Event)');
            });
        }
        this.initializeTheme();
    }

    async startGame() {
        const hostNameInput = document.getElementById('hostNameInput');
        const hostName = hostNameInput.value.trim();
        if (!hostName || hostName.length < 2) {
            this.showNameError(hostNameInput, 'Ïù¥Î¶ÑÏùÑ 2Ïûê Ïù¥ÏÉÅ ÏûÖÎ†•ÌïòÏÑ∏Ïöî');
            return;
        }
        
        if (!this.database) {
            alert('FirebaseÏóê Ïó∞Í≤∞ Ï§ëÏûÖÎãàÎã§. Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.');
            return;
        }
        try {
            this.gameCode = this.generateRoomCode();
            this.hostPlayerName = hostName;
            this.isRoomHost = true;
            this.isRoomGuest = false;
            this.isOnlineGame = true;
            
            const roomData = {
                hostId: this.playerId,
                hostName: hostName,
                guestId: null,
                guestName: null,
                gameStarted: false,
                currentPlayer: 'cho',
                board: this.getInitialBoard(),
                capturedPieces: { cho: [], han: [] },
                lastActivity: firebase.database.ServerValue.TIMESTAMP
            };
            this.gameRef = this.database.ref('janggi_games/' + this.gameCode);
            await this.gameRef.set(roomData);
            
            document.getElementById('gameMenu').style.display = 'none';
            document.getElementById('gameContainer').style.display = 'block';
            this.showGameCode();
            this.initializeBoard();
            this.renderBoard();
            this.showWaitingState();
            this.updatePlayerNames();
            this.setupFirebaseListeners();
        } catch (error) {
            console.error('‚ùå Failed to create room:', error);
            alert('Î∞© ÎßåÎì§Í∏∞Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§: ' + error.message);
        }
    }

    async resetGameOnline() {
        if (!this.gameRef || !this.isOnlineGame) {
            this.resetGame();
            return;
        }
        try {
            await this.gameRef.update({
                board: this.getInitialBoard(),
                currentPlayer: 'cho',
                capturedPieces: { cho: [], han: [] },
                gameStarted: true,
                isGameInProgress: true,
                gameEnded: false,
                winner: null,
                gameRestarted: firebase.database.ServerValue.TIMESTAMP,
                lastActivity: firebase.database.ServerValue.TIMESTAMP
            });
        } catch (error) {
            console.error('‚ùå Game restart failed:', error);
            alert('Í≤åÏûÑ Ïû¨ÏãúÏûëÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§: ' + error.message);
        }
    }

    resetGame() {
        this.stopTurnTimer();
        this.currentPlayer = 'cho';
        this.selectedSquare = null;
        this.capturedPieces = { cho: [], han: [] };
        this.currentTurnTime = this.turnTimeLimit;
        this.isGameInProgress = false;
        this.isMovePending = false;
        
        // Î≥¥Îìú ÏôÑÏ†ÑÌûà Ï¥àÍ∏∞Ìôî
        const boardElement = document.getElementById('janggiboard');
        if (boardElement) {
            boardElement.innerHTML = '';
        }
        
        this.initializeBoard();
        
        // (4,4) ÏúÑÏπò ÌäπÎ≥Ñ Ï†ïÎ¶¨
        setTimeout(() => {
            this.cleanupSpecificSquare(4, 4);
        }, 100);
        
        this.renderBoard();
        this.showWaitingState();
    }
    
    backToMenu() {
        // Clean up Firebase listeners to prevent memory leaks
        if (this.gameRef && this.listeners.length > 0) {
            this.listeners.forEach(({ ref, listener }) => ref.off('value', listener));
            this.listeners = [];
            this.gameRef = null;
        }

        this.stopTurnTimer();
        this.hideGameCode();
        this.hideAllButtons();
        this.clearRoomCodeInput();
        this.clearNameInputs();
        this.hidePlayerNames();
        document.getElementById('gameContainer').style.display = 'none';
        document.getElementById('gameMenu').style.display = 'block';
        this.gameStarted = false;
        this.isGameInProgress = false;
        this.isRoomHost = false;
        this.isRoomGuest = false;
        this.isOnlineGame = false;
        this.hostPlayerName = '';
        this.guestPlayerName = '';
        document.getElementById('janggiboard').innerHTML = '';
    }

    initializeBoard() {
        this.board = this.getInitialBoard();
    }
    
    getInitialBoard() {
        const board = Array(this.rows).fill(null).map(() => Array(this.cols).fill(null));
        // ÌïúÎÇòÎùº (Red)
        board[0][0] = { type: 'chariot', color: 'han' };
        board[0][1] = { type: 'elephant', color: 'han' };
        board[0][2] = { type: 'horse', color: 'han' };
        board[0][3] = { type: 'guard', color: 'han' };
        board[0][5] = { type: 'guard', color: 'han' };
        board[0][6] = { type: 'elephant', color: 'han' };
        board[0][7] = { type: 'horse', color: 'han' };
        board[0][8] = { type: 'chariot', color: 'han' };
        board[1][4] = { type: 'king', color: 'han' };
        board[2][1] = { type: 'cannon', color: 'han' };
        board[2][7] = { type: 'cannon', color: 'han' };
        board[3][0] = { type: 'soldier', color: 'han' };
        board[3][2] = { type: 'soldier', color: 'han' };
        board[3][4] = { type: 'soldier', color: 'han' };
        board[3][6] = { type: 'soldier', color: 'han' };
        board[3][8] = { type: 'soldier', color: 'han' };

        // Ï¥àÎÇòÎùº (Blue/Green)
        board[9][0] = { type: 'chariot', color: 'cho' };
        board[9][1] = { type: 'elephant', color: 'cho' };
        board[9][2] = { type: 'horse', color: 'cho' };
        board[9][3] = { type: 'guard', color: 'cho' };
        board[9][5] = { type: 'guard', color: 'cho' };
        board[9][6] = { type: 'elephant', color: 'cho' };
        board[9][7] = { type: 'horse', color: 'cho' };
        board[9][8] = { type: 'chariot', color: 'cho' };
        board[8][4] = { type: 'king', color: 'cho' };
        board[7][1] = { type: 'cannon', color: 'cho' };
        board[7][7] = { type: 'cannon', color: 'cho' };
        board[6][0] = { type: 'soldier', color: 'cho' };
        board[6][2] = { type: 'soldier', color: 'cho' };
        board[6][4] = { type: 'soldier', color: 'cho' };
        board[6][6] = { type: 'soldier', color: 'cho' };
        board[6][8] = { type: 'soldier', color: 'cho' };
        return board;
    }

    renderBoard() {
        const boardElement = document.getElementById('janggiboard');
        if (!boardElement) return;
        
        // ÏôÑÏ†ÑÌûà Ï¥àÍ∏∞ÌôîÌïòÏó¨ Ï§ëÎ≥µ Îßê Î¨∏Ï†ú Ìï¥Í≤∞
        boardElement.innerHTML = '';
        
        // Í∏∞Ï°¥ Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑàÎèÑ Î™®Îëê Ï†úÍ±∞
        const existingSquares = boardElement.querySelectorAll('.square');
        existingSquares.forEach(square => {
            square.removeEventListener('click', square.clickHandler);
        });
        
        for (let row = 0; row < this.rows; row++) {
            for (let col = 0; col < this.cols; col++) {
                const square = document.createElement('div');
                square.className = 'square';
                square.dataset.row = row;
                square.dataset.col = col;
                
                // ÌäπÏ†ï ÏúÑÏπò (4,4) ÎîîÎ≤ÑÍπÖ
                if (row === 4 && col === 4) {
                    console.log(`üîç Rendering position (4,4), piece:`, this.board[row][col]);
                }
                
                // Í∏∞Ï°¥ piece ÏöîÏÜåÎì§ ÏôÑÏ†ÑÌûà Ï†úÍ±∞
                const existingPieces = square.querySelectorAll('.piece');
                existingPieces.forEach(piece => piece.remove());
                
                const piece = this.board[row][col];
                if (piece) {
                    const pieceElement = document.createElement('div');
                    pieceElement.className = `piece ${piece.color}`;
                    pieceElement.textContent = this.pieces[piece.color][piece.type];
                    square.appendChild(pieceElement);
                    
                    // ÌäπÏ†ï ÏúÑÏπò (4,4) ÎîîÎ≤ÑÍπÖ
                    if (row === 4 && col === 4) {
                        console.log(`‚úÖ Piece added to (4,4):`, pieceElement);
                    }
                }
                
                // Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà Ï†ÄÏû•ÌïòÏó¨ ÎÇòÏ§ëÏóê Ï†úÍ±∞Ìï† Ïàò ÏûàÎèÑÎ°ù Ìï®
                const clickHandler = () => this.handleSquareClick(row, col);
                square.clickHandler = clickHandler;
                square.addEventListener('click', clickHandler);
                
                boardElement.appendChild(square);
            }
        }
        
        // Î†åÎçîÎßÅ ÏôÑÎ£å ÌõÑ (4,4) ÏúÑÏπò Í∞ïÏ†ú Í≤ÄÏ¶ù
        setTimeout(() => {
            this.validateSpecificSquare(4, 4);
        }, 50);
        
        this.updateCapturedPieces();
    }
    
    validateSpecificSquare(row, col) {
        const targetSquare = document.querySelector(`.square[data-row='${row}'][data-col='${col}']`);
        const boardPiece = this.board[row][col];
        
        if (targetSquare) {
            const domPieces = targetSquare.querySelectorAll('.piece');
            
            if (boardPiece && domPieces.length === 0) {
                // Î≥¥ÎìúÏóêÎäî ÎßêÏù¥ ÏûàÎäîÎç∞ DOMÏóêÎäî ÏóÜÎäî Í≤ΩÏö∞
                console.log(`‚ö†Ô∏è Missing piece in DOM at (${row},${col}), adding:`, boardPiece);
                const pieceElement = document.createElement('div');
                pieceElement.className = `piece ${boardPiece.color}`;
                pieceElement.textContent = this.pieces[boardPiece.color][boardPiece.type];
                targetSquare.appendChild(pieceElement);
            } else if (!boardPiece && domPieces.length > 0) {
                // Î≥¥ÎìúÏóêÎäî ÎßêÏù¥ ÏóÜÎäîÎç∞ DOMÏóêÎäî ÏûàÎäî Í≤ΩÏö∞
                console.log(`‚ö†Ô∏è Extra pieces in DOM at (${row},${col}), removing:`, domPieces.length);
                domPieces.forEach(piece => piece.remove());
            } else if (boardPiece && domPieces.length > 1) {
                // Ï§ëÎ≥µÎêú ÎßêÎì§Ïù¥ ÏûàÎäî Í≤ΩÏö∞
                console.log(`‚ö†Ô∏è Duplicate pieces in DOM at (${row},${col}), cleaning up`);
                domPieces.forEach((piece, index) => {
                    if (index > 0) piece.remove(); // Ï≤´ Î≤àÏß∏Îßå ÎÇ®Í∏∞Í≥† Ï†úÍ±∞
                });
            }
        }
    }

    async handleSquareClick(row, col) {
        if (!this.gameStarted || !this.isGameInProgress || this.isMovePending) {
            return;
        }
        
        const myColor = this.isRoomHost ? 'cho' : 'han';
        if (this.currentPlayer !== myColor) {
            alert("ÏÉÅÎåÄÎ∞©Ïùò Ï∞®Î°ÄÏûÖÎãàÎã§.");
            return;
        }
        
        const piece = this.board[row][col];
        
        if (!this.selectedSquare) {
            if (piece && piece.color === this.currentPlayer) {
                this.selectedSquare = { row, col };
                this.highlightValidMoves(row, col);
            }
        } else {
            const fromRow = this.selectedSquare.row;
            const fromCol = this.selectedSquare.col;

            if (fromRow === row && fromCol === col) {
                this.selectedSquare = null;
                this.clearHighlights();
            } else if (piece && piece.color === this.currentPlayer) {
                this.selectedSquare = { row, col };
                this.clearHighlights();
                this.highlightValidMoves(row, col);
            } else {
                if (this.isValidMove(fromRow, fromCol, row, col)) {
                    await this.makeMove(fromRow, fromCol, row, col);
                }
                this.selectedSquare = null;
                this.clearHighlights();
            }
        }
    }

    highlightValidMoves(row, col) {
        this.clearHighlights();
        document.querySelector(`.square[data-row='${row}'][data-col='${col}']`).classList.add('selected');
        for (let r = 0; r < this.rows; r++) {
            for (let c = 0; c < this.cols; c++) {
                if (this.isValidMove(row, col, r, c)) {
                    const targetSquare = document.querySelector(`.square[data-row='${r}'][data-col='${c}']`);
                    if (this.board[r][c]) {
                        targetSquare.classList.add('capture');
                    } else {
                        targetSquare.classList.add('valid-move');
                    }
                }
            }
        }
    }

    clearHighlights() {
        document.querySelectorAll('.square').forEach(s => s.classList.remove('selected', 'valid-move', 'capture'));
    }
    
    cleanupSpecificSquare(row, col) {
        // ÌäπÏ†ï ÏúÑÏπòÏùò DOM squareÎ•º Í∞ïÏ†úÎ°ú Ï†ïÎ¶¨
        const targetSquare = document.querySelector(`.square[data-row='${row}'][data-col='${col}']`);
        if (targetSquare) {
            // Í∏∞Ï°¥ piece ÏöîÏÜåÎì§ Î™®Îëê Ï†úÍ±∞
            const pieces = targetSquare.querySelectorAll('.piece');
            pieces.forEach(piece => {
                console.log(`üßπ Removing piece from (${row},${col}):`, piece);
                piece.remove();
            });
            
            // Î≥¥Îìú Îç∞Ïù¥ÌÑ∞ÏôÄ ÏùºÏπòÌïòÏßÄ ÏïäÎäî Í≤ΩÏö∞ Í∞ïÏ†ú ÎèôÍ∏∞Ìôî
            const boardPiece = this.board[row][col];
            if (boardPiece && pieces.length === 0) {
                console.log(`üîß Adding missing piece to (${row},${col}):`, boardPiece);
                const pieceElement = document.createElement('div');
                pieceElement.className = `piece ${boardPiece.color}`;
                pieceElement.textContent = this.pieces[boardPiece.color][boardPiece.type];
                targetSquare.appendChild(pieceElement);
            } else if (!boardPiece && pieces.length > 0) {
                console.log(`üóëÔ∏è Removing extra pieces from (${row},${col})`);
                pieces.forEach(piece => piece.remove());
            }
        }
    }

    // ### Ïû•Í∏∞ ÌñâÎßàÎ≤ï (ÌïµÏã¨ Î°úÏßÅ) ###
    isValidMove(fromRow, fromCol, toRow, toCol) {
        if (toRow < 0 || toRow >= this.rows || toCol < 0 || toCol >= this.cols) return false;
        
        const piece = this.board[fromRow][fromCol];
        const targetPiece = this.board[toRow][toCol];

        if (!piece) return false;
        if (targetPiece && targetPiece.color === piece.color) return false;

        switch (piece.type) {
            case 'king':
            case 'guard':
                return this.isPalaceMove(fromRow, fromCol, toRow, toCol, piece.color);
            case 'horse':
                return this.isHorseMove(fromRow, fromCol, toRow, toCol);
            case 'elephant':
                 return this.isElephantMove(fromRow, fromCol, toRow, toCol);
            case 'chariot':
                return this.isChariotMove(fromRow, fromCol, toRow, toCol);
            case 'cannon':
                return this.isCannonMove(fromRow, fromCol, toRow, toCol);
            case 'soldier':
                return this.isSoldierMove(fromRow, fromCol, toRow, toCol, piece.color);
            default:
                return false;
        }
    }

    isPalace(row, col) {
        const isHanPalace = (row >= 0 && row <= 2) && (col >= 3 && col <= 5);
        const isChoPalace = (row >= 7 && row <= 9) && (col >= 3 && col <= 5);
        return { isHanPalace, isChoPalace };
    }

    isPalaceMove(fromRow, fromCol, toRow, toCol, color) {
        const { isHanPalace, isChoPalace } = this.isPalace(toRow, toCol);
        if (color === 'han' && !isHanPalace) return false;
        if (color === 'cho' && !isChoPalace) return false;
        
        const rowDiff = Math.abs(toRow - fromRow);
        const colDiff = Math.abs(toCol - fromCol);
        
        // Í∂ÅÏÑ± ÎÇ¥ ÎåÄÍ∞ÅÏÑ† Í∏∏ ÏúÑÏπò
        const diagonalPoints = {
            han: [[0, 3], [1, 4], [2, 5], [0, 5], [2, 3]],
            cho: [[7, 3], [8, 4], [9, 5], [7, 5], [9, 3]]
        };
        const palace = color === 'han' ? diagonalPoints.han : diagonalPoints.cho;
        const isFromDiagonal = palace.some(p => p[0] === fromRow && p[1] === fromCol);
        const isToDiagonal = palace.some(p => p[0] === toRow && p[1] === toCol);
        
        if (rowDiff === 1 && colDiff === 1 && isFromDiagonal && isToDiagonal) return true;
        if (rowDiff + colDiff === 1) return true;
        
        return false;
    }

    isChariotMove(fromRow, fromCol, toRow, toCol) {
        const rowDiff = Math.abs(toRow - fromRow);
        const colDiff = Math.abs(toCol - fromCol);
        
        // ÏßÅÏÑ† Ïù¥Îèô
        if ((rowDiff > 0 && colDiff === 0) || (rowDiff === 0 && colDiff > 0)) {
            return this.countPiecesOnPath(fromRow, fromCol, toRow, toCol) === 0;
        }
        
        // Í∂ÅÏÑ± ÎÇ¥ ÎåÄÍ∞ÅÏÑ† Ïù¥Îèô
        const { isHanPalace: fromHan } = this.isPalace(fromRow, fromCol);
        const { isHanPalace: toHan } = this.isPalace(toRow, toCol);
        const { isChoPalace: fromCho } = this.isPalace(fromRow, fromCol);
        const { isChoPalace: toCho } = this.isPalace(toRow, toCol);

        if ((fromHan && toHan) || (fromCho && toCho)) {
             if (rowDiff === 1 && colDiff === 1) return true; // Ìïú Ïπ∏ ÎåÄÍ∞ÅÏÑ† Ïù¥Îèô
             if (rowDiff === 2 && colDiff === 2 && (fromRow+fromCol)%2 === 0 ) { // Îëê Ïπ∏ ÎåÄÍ∞ÅÏÑ† Ïù¥Îèô
                 const midRow = (fromRow + toRow) / 2;
                 const midCol = (fromCol + toCol) / 2;
                 if (midRow === 1 || midRow === 8) { // Í∂Å Ï§ëÏïô
                    return this.board[midRow][midCol] === null;
                 }
             }
        }
        return false;
    }

    isHorseMove(fromRow, fromCol, toRow, toCol) {
        const rowDiff = Math.abs(toRow - fromRow);
        const colDiff = Math.abs(toCol - fromCol);

        if (!((rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2))) return false;

        if (rowDiff === 2) { // ÏÑ∏Î°úÎ°ú 2Ïπ∏ Ïù¥Îèô
            if (this.board[fromRow + Math.sign(toRow - fromRow)][fromCol]) return false;
        } else { // Í∞ÄÎ°úÎ°ú 2Ïπ∏ Ïù¥Îèô
            if (this.board[fromRow][fromCol + Math.sign(toCol - fromCol)]) return false;
        }
        return true;
    }
    
    isElephantMove(fromRow, fromCol, toRow, toCol) {
        const rowDiff = Math.abs(toRow - fromRow);
        const colDiff = Math.abs(toCol - fromCol);

        if (!((rowDiff === 3 && colDiff === 2) || (rowDiff === 2 && colDiff === 3))) return false;

        let block1_r, block1_c, block2_r, block2_c;
        const r_sign = Math.sign(toRow - fromRow);
        const c_sign = Math.sign(toCol - fromCol);

        if(rowDiff === 3) { // ÏÑ∏Î°ú 3Ïπ∏
            block1_r = fromRow + r_sign;
            block1_c = fromCol;
            block2_r = fromRow + 2 * r_sign;
            block2_c = fromCol + c_sign;
        } else { // Í∞ÄÎ°ú 3Ïπ∏
            block1_r = fromRow;
            block1_c = fromCol + c_sign;
            block2_r = fromRow + r_sign;
            block2_c = fromCol + 2 * c_sign;
        }
        
        if (this.board[block1_r][block1_c] || this.board[block2_r][block2_c]) return false;

        return true;
    }

    isCannonMove(fromRow, fromCol, toRow, toCol) {
        const target = this.board[toRow][toCol];
        if (target && target.type === 'cannon') return false;

        const rowDiff = Math.abs(toRow - fromRow);
        const colDiff = Math.abs(toCol - fromCol);

        if ((rowDiff > 0 && colDiff > 0)) return false; // ÎåÄÍ∞ÅÏÑ† Ïù¥Îèô Î∂àÍ∞Ä

        const jumpCount = this.countPiecesOnPath(fromRow, fromCol, toRow, toCol);
        if (jumpCount !== 1) return false;
        
        // Ìè¨Îäî Ìè¨Î•º Îõ∞Ïñ¥ÎÑòÏùÑ Ïàò ÏóÜÏùå
        const stepR = Math.sign(toRow - fromRow);
        const stepC = Math.sign(toCol - fromCol);
        let r = fromRow + stepR;
        let c = fromCol + stepC;
        while (r !== toRow || c !== toCol) {
            if (this.board[r][c] && this.board[r][c].type === 'cannon') {
                return false;
            }
            r += stepR;
            c += stepC;
        }
        return true;
    }

    isSoldierMove(fromRow, fromCol, toRow, toCol, color) {
        const direction = color === 'cho' ? -1 : 1;
        const rowDiff = toRow - fromRow;
        const colDiff = Math.abs(toCol - fromCol);

        // ÏßÅÏßÑ
        if (rowDiff === direction && colDiff === 0) return true;
        // ÏòÜÏúºÎ°ú
        if (rowDiff === 0 && colDiff === 1) return true;
        
        // Í∂ÅÏÑ± ÎÇ¥ ÎåÄÍ∞ÅÏÑ†
        const { isHanPalace, isChoPalace } = this.isPalace(fromRow, fromCol);
        const enemyPalace = color === 'cho' ? isHanPalace : isChoPalace;
        
        if (enemyPalace && rowDiff === direction && colDiff === 1) return true;
        
        return false;
    }

    countPiecesOnPath(fromRow, fromCol, toRow, toCol) {
        let count = 0;
        const stepR = Math.sign(toRow - fromRow);
        const stepC = Math.sign(toCol - fromCol);
        let r = fromRow + stepR;
        let c = fromCol + stepC;
        while (r !== toRow || c !== toCol) {
            if (this.board[r][c]) count++;
            r += stepR;
            c += stepC;
        }
        return count;
    }

    // ### ÌñâÎßàÎ≤ï ÎÅù ###

    async makeMove(fromRow, fromCol, toRow, toCol) {
        this.isMovePending = true;

        const piece = this.board[fromRow][fromCol];
        const capturedPiece = this.board[toRow][toCol];
        let gameEnded = false;
        let winner = null;

        // ÌäπÏ†ï ÏúÑÏπò (4,4) ÎîîÎ≤ÑÍπÖ
        if (toRow === 4 && toCol === 4) {
            console.log(`üéØ Move to (4,4): piece=${piece?.type}, capturedPiece=${capturedPiece?.type}`);
            console.log(`üéØ Board before move at (4,4):`, this.board[4][4]);
        }
        if (fromRow === 4 && fromCol === 4) {
            console.log(`üîÑ Move from (4,4): piece=${piece?.type}`);
        }

        if (capturedPiece) {
            this.capturedPieces[capturedPiece.color].push(capturedPiece);
            console.log(`üéØ Piece captured: ${capturedPiece.color} ${capturedPiece.type} at (${toRow},${toCol})`);
            console.log(`üì¶ Total captured pieces:`, this.capturedPieces);
            if (capturedPiece.type === 'king') {
                gameEnded = true;
                winner = piece.color;
            }
        }
        this.board[toRow][toCol] = piece;
        this.board[fromRow][fromCol] = null;
        
        // ÌäπÏ†ï ÏúÑÏπò (4,4) ÎîîÎ≤ÑÍπÖ - Ïù¥Îèô ÌõÑ
        if (toRow === 4 && toCol === 4) {
            console.log(`‚úÖ Board after move to (4,4):`, this.board[4][4]);
        }
        if (fromRow === 4 && fromCol === 4) {
            console.log(`‚úÖ Board after move from (4,4):`, this.board[4][4]);
        }
        
        // (4,4) ÏúÑÏπò Í∞ïÏ†ú Ï†ïÎ¶¨
        this.cleanupSpecificSquare(4, 4);
        
        this.renderBoard();
        
        if (this.gameRef && this.isOnlineGame) {
            try {
                const updateData = {
                    board: this.board,
                    capturedPieces: this.capturedPieces,
                    lastActivity: firebase.database.ServerValue.TIMESTAMP
                };
                if (gameEnded) {
                    updateData.gameEnded = true;
                    updateData.winner = winner;
                    updateData.isGameInProgress = false; 
                } else {
                    updateData.currentPlayer = this.currentPlayer === 'cho' ? 'han' : 'cho';
                }
                await this.gameRef.update(updateData);
            } catch (error) {
                console.error('‚ùå Failed to send move:', error);
                this.isMovePending = false;
                alert('ÏàòÎ•º Ï†ÑÏÜ°ÌïòÎäî Îç∞ Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.');
            }
        }
    }
    
    endGame(winner) {
        this.isGameInProgress = false;
        this.gameStarted = false;
        this.stopTurnTimer();
        
        const gameStatus = document.getElementById('gameStatus');
        const winnerText = winner === 'cho' ? 'Ï¥à(Ê•ö)' : 'Ìïú(Êº¢)';
        gameStatus.textContent = `üéâ Í≤åÏûÑ Ï¢ÖÎ£å! ${winnerText}Ïùò ÏäπÎ¶¨! üéâ`;
        
        const myColor = this.isRoomHost ? 'cho' : 'han';
        setTimeout(() => {
            if (winner === myColor) {
                alert(`üéä Ï∂ïÌïòÌï©ÎãàÎã§! ÏäπÎ¶¨ÌïòÏÖ®ÏäµÎãàÎã§! üéä`);
            } else {
                alert(`üòä ÏàòÍ≥†ÌïòÏÖ®ÏäµÎãàÎã§! Îã§Ïãú ÎèÑÏ†ÑÌï¥Î≥¥ÏÑ∏Ïöî! üí™`);
            }
        }, 500);
    }

    updateGameStatus() {
        const playerText = this.currentPlayer === 'cho' ? "Ï¥à(Ê•ö)Ïùò Ï∞®Î°Ä" : "Ìïú(Êº¢)Ïùò Ï∞®Î°Ä";                                                                                                                                      
        document.getElementById('currentPlayer').textContent = playerText;
        if (this.isGameInProgress) document.getElementById('gameStatus').textContent = 'Í≤åÏûÑ ÏßÑÌñâ Ï§ë';
        this.updateTimerDisplay();
    }

    updateCapturedPieces() {
        const capturedChoEl = document.getElementById('capturedCho');
        const capturedHanEl = document.getElementById('capturedHan');
        if (!this.capturedPieces) this.capturedPieces = { cho: [], han: [] };
        
        // Ïû°Ìûå Í∏∞Î¨ºÏö© Î≥ÑÎèÑ CSS ÌÅ¥ÎûòÏä§ ÏÇ¨Ïö©ÌïòÏó¨ ÏúÑÏπò Î¨∏Ï†ú Ìï¥Í≤∞
        capturedChoEl.innerHTML = this.capturedPieces.cho.map(p => 
            `<span class="captured-piece cho">${this.pieces.cho[p.type]}</span>`
        ).join(' ');
        capturedHanEl.innerHTML = this.capturedPieces.han.map(p => 
            `<span class="captured-piece han">${this.pieces.han[p.type]}</span>`
        ).join(' ');
        
        console.log(`üìä Captured pieces updated - Ï¥à: ${this.capturedPieces.cho.length}, Ìïú: ${this.capturedPieces.han.length}`);
    }

    // --- Ïù¥Ìïò ÏΩîÎìúÎäî Ï≤¥Ïä§ Í≤åÏûÑÍ≥º Í±∞Ïùò ÎèôÏùºÌïú UI/Ïò®ÎùºÏù∏ Î°úÏßÅ ---
    
    startTurnTimer() {
        this.stopTurnTimer();
        this.currentTurnTime = this.turnTimeLimit;
        this.updateTimerDisplay();
        this.timerInterval = setInterval(() => {
            this.currentTurnTime--;
            this.updateTimerDisplay();
            if (this.currentTurnTime <= 0) this.handleTimeOut();
        }, 1000);
    }

    stopTurnTimer() {
        clearInterval(this.timerInterval);
        this.timerInterval = null;
    }

    resetTurnTimer() {
        this.stopTurnTimer();
        if(this.isGameInProgress) {
            this.startTurnTimer();
        }
    }
    
    updateTimerDisplay() {
        const timerElement = document.getElementById('turnTimer');
        if (timerElement) {
            timerElement.textContent = this.currentTurnTime;
            timerElement.classList.toggle('warning', this.currentTurnTime <= 5);
        }
    }
    
    async handleTimeOut() {
        this.stopTurnTimer();
        const myColor = this.isRoomHost ? 'cho' : 'han';
        if (this.currentPlayer === myColor) {
            alert('ÏãúÍ∞Ñ Ï¢ÖÎ£å! ÏûÑÏùòÏùò ÏàòÍ∞Ä ÎëêÏñ¥ÏßëÎãàÎã§.');
            const validMoves = this.getAllValidMoves(this.currentPlayer);
            if (validMoves.length > 0) {
                const randomMove = validMoves[Math.floor(Math.random() * validMoves.length)];
                await this.makeMove(randomMove.fromRow, randomMove.fromCol, randomMove.toRow, randomMove.toCol);
            }
        }
    }

    getAllValidMoves(player) {
        const moves = [];
        for (let r = 0; r < this.rows; r++) {
            for (let c = 0; c < this.cols; c++) {
                const piece = this.board[r][c];
                if (piece && piece.color === player) {
                    for (let tr = 0; tr < this.rows; tr++) {
                        for (let tc = 0; tc < this.cols; tc++) {
                            if (this.isValidMove(r, c, tr, tc)) {
                                moves.push({ fromRow: r, fromCol: c, toRow: tr, toCol: tc });
                            }
                        }
                    }
                }
            }
        }
        return moves;
    }

    setupFirebaseListeners() {
        if (!this.gameRef) return;
        const gameListener = this.gameRef.on('value', (snapshot) => {
            const gameData = snapshot.val();
            if (!gameData) {
                alert('Í≤åÏûÑ Î∞©Ïù¥ ÏÇ¨ÎùºÏ°åÏäµÎãàÎã§. Î©îÏù∏ Î©îÎâ¥Î°ú ÎèåÏïÑÍ∞ëÎãàÎã§.');
                this.backToMenu();
                return;
            }
            
            this.hostPlayerName = gameData.hostName;
            if (gameData.guestId && !this.guestPlayerName) {
                this.guestPlayerName = gameData.guestName;
                if (this.isRoomHost) {
                    this.showWaitingState();
                }
            }
            this.updatePlayerNames();

            if (gameData.board) this.syncBoard(gameData.board);

            if (gameData.capturedPieces) {
                this.capturedPieces = {
                    cho: Array.isArray(gameData.capturedPieces.cho) ? gameData.capturedPieces.cho : [],
                    han: Array.isArray(gameData.capturedPieces.han) ? gameData.capturedPieces.han : []
                };
                this.updateCapturedPieces();
            }

            if (gameData.currentPlayer !== this.currentPlayer) {
                this.currentPlayer = gameData.currentPlayer;
                this.updateGameStatus();
                this.resetTurnTimer();
            }
            
            this.isMovePending = false;
            
            if (gameData.gameStarted && !this.isGameInProgress) {
                this.handleGameStart();
            }
            if (gameData.gameEnded && this.isGameInProgress) {
                this.endGame(gameData.winner);
            }
            if (gameData.gameRestarted && gameData.gameStarted && !gameData.gameEnded) {
                 if(!this.isGameInProgress || !this.gameStarted) {
                   this.handleGameRestart(gameData);
                }
            }
        });
        this.listeners.push({ ref: this.gameRef, listener: gameListener });
    }

    syncBoard(newBoard) {
        if (!newBoard) return;
        const verifiedBoard = Array(this.rows).fill(null).map(() => Array(this.cols).fill(null));
        for (let r = 0; r < this.rows; r++) {
            if (newBoard[r]) {
                for (let c = 0; c < this.cols; c++) {
                    verifiedBoard[r][c] = newBoard[r][c] || null;
                }
            }
        }
        this.board = verifiedBoard;
        this.renderBoard();
    }
    
    handleGameStart() {
        this.gameStarted = true;
        this.isGameInProgress = true;
        this.currentPlayer = 'cho';
        this.isMovePending = false;
        this.showGameButtons();
        this.updateGameStatus();
        this.startTurnTimer();
    }

    handleGameRestart(gameData) {
        this.gameStarted = true;
        this.isGameInProgress = true;
        this.currentPlayer = 'cho';
        this.selectedSquare = null;
        this.currentTurnTime = this.turnTimeLimit;
        this.isMovePending = false;
        
        this.capturedPieces = gameData.capturedPieces || { cho: [], han: [] };
        
        document.getElementById('gameStatus').textContent = 'Í≤åÏûÑÏù¥ Ïû¨ÏãúÏûëÎêòÏóàÏäµÎãàÎã§!';
        
        this.showGameButtons();
        this.resetTurnTimer();
        this.updateGameStatus();
        
        if (gameData.board) {
            this.syncBoard(gameData.board);
        }
        
        setTimeout(() => alert('üéÆ Í≤åÏûÑÏù¥ Ïû¨ÏãúÏûëÎêòÏóàÏäµÎãàÎã§! üéÆ'), 500);
    }
    
    generateRoomCode() {
        return Math.floor(10000 + Math.random() * 90000).toString();
    }
    
    showGameCode() {
        const gameCodeContainer = document.getElementById('gameCodeContainer');
        const gameCodeElement = document.getElementById('gameCode');
        if (gameCodeContainer && gameCodeElement && this.gameCode) {
            gameCodeElement.textContent = this.gameCode;
            gameCodeContainer.style.display = 'flex';
        }
    }
    
    hideGameCode() {
        document.getElementById('gameCodeContainer').style.display = 'none';
        this.gameCode = null;
    }
    
    copyGameCode() {
        if (this.gameCode) {
            navigator.clipboard.writeText(this.gameCode).then(() => {
                const copyBtn = document.getElementById('copyCodeBtn');
                const originalText = copyBtn.textContent;
                copyBtn.textContent = '‚úì';
                setTimeout(() => { copyBtn.textContent = originalText; }, 1500);
            }).catch(err => console.error('Failed to copy code: ', err));
        }
    }
    
    async startActualGame() {
        if (!this.isRoomHost || !this.gameRef) return;
        if (!this.guestPlayerName) {
            alert('ÏÉÅÎåÄÎ∞©Ïù¥ Îì§Ïñ¥Ïò¨ ÎïåÍπåÏßÄ Í∏∞Îã§Î†§Ï£ºÏÑ∏Ïöî!');
            return;
        }
        try {
            await this.gameRef.update({
                gameStarted: true,
                isGameInProgress: true,
                lastActivity: firebase.database.ServerValue.TIMESTAMP
            });
        } catch (error) {
            console.error('‚ùå Í≤åÏûÑ ÏãúÏûë Ïã§Ìå®:', error);
            alert('Í≤åÏûÑ ÏãúÏûëÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§: ' + error.message);
        }
    }
    
    showWaitingState() {
        const playerElement = document.getElementById('currentPlayer');
        const statusElement = document.getElementById('gameStatus');
        const startBtn = document.getElementById('startGameBtnInRoom');
        
        playerElement.textContent = 'ÎåÄÍ∏∞Ï§ë';
        
        if (this.isRoomHost) {
            if (this.guestPlayerName) {
                statusElement.textContent = 'ÏÉÅÎåÄÎ∞©Ïù¥ Ï†ëÏÜçÌñàÏäµÎãàÎã§! Í≤åÏûÑÏùÑ ÏãúÏûëÌïòÏÑ∏Ïöî.';
                startBtn.style.display = 'inline-block';
                startBtn.disabled = false;
                startBtn.textContent = 'Í≤åÏûÑ ÏãúÏûë';
            } else {
                statusElement.textContent = 'ÏÉÅÎåÄÎ∞©ÏùÑ Í∏∞Îã§Î¶¨Îäî Ï§ë... ÏΩîÎìúÎ•º Í≥µÏú†ÌïòÏÑ∏Ïöî!';
                startBtn.style.display = 'inline-block';
                startBtn.disabled = true;
                startBtn.textContent = 'ÎåÄÍ∏∞Ï§ë...';
            }
        } else if (this.isRoomGuest) {
            statusElement.textContent = 'Î∞©Ïû•Ïù¥ Í≤åÏûÑÏùÑ ÏãúÏûëÌï† ÎïåÍπåÏßÄ Í∏∞Îã§Î†§Ï£ºÏÑ∏Ïöî!';
            startBtn.style.display = 'none';
        }
        
        this.hideResetButton();
        this.updatePlayerNames();
    }
    
    showGameButtons() {
        document.getElementById('startGameBtnInRoom').style.display = 'none';
        document.getElementById('resetBtn').style.display = 'inline-block';
    }
    
    hideResetButton() {
        document.getElementById('resetBtn').style.display = 'none';
    }
    
    hideAllButtons() {
        document.getElementById('startGameBtnInRoom').style.display = 'none';
        document.getElementById('resetBtn').style.display = 'none';
    }
    
    async joinRoom() {
        const guestNameInput = document.getElementById('guestNameInput');
        const guestName = guestNameInput.value.trim();
        const codeInput = document.getElementById('roomCodeInput');
        const enteredCode = codeInput.value.trim();
        if (guestName.length < 2) {
            this.showNameError(guestNameInput, 'Ïù¥Î¶ÑÏùÑ 2Ïûê Ïù¥ÏÉÅ ÏûÖÎ†•ÌïòÏÑ∏Ïöî');
            return;
        }
        if (enteredCode.length !== 5 || !/^\d{5}$/.test(enteredCode)) {
            this.showJoinError('5ÏûêÎ¶¨ Ïà´Ïûê ÏΩîÎìúÎ•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî');
            return;
        }
        if (!this.database) {
            this.showJoinError('ÏÑúÎ≤Ñ Ïó∞Í≤∞ Ï§ë...');
            return;
        }
        try {
            this.gameCode = enteredCode;
            this.gameRef = this.database.ref('janggi_games/' + this.gameCode);
            const snapshot = await this.gameRef.once('value');
            const roomData = snapshot.val();
            if (!roomData) throw new Error('Ï°¥Ïû¨ÌïòÏßÄ ÏïäÎäî Î∞©ÏûÖÎãàÎã§');
            if (roomData.guestId) throw new Error('Î∞©Ïù¥ Í∞ÄÎìù Ï∞ºÏäµÎãàÎã§');
            
            await this.gameRef.update({
                guestId: this.playerId,
                guestName: guestName,
                lastActivity: firebase.database.ServerValue.TIMESTAMP
            });

            this.guestPlayerName = guestName;
            this.hostPlayerName = roomData.hostName;
            this.isRoomHost = false;
            this.isRoomGuest = true;
            this.isOnlineGame = true;
            
            document.getElementById('gameMenu').style.display = 'none';
            document.getElementById('gameContainer').style.display = 'block';
            
            this.syncBoard(roomData.board);
            this.showWaitingState();
            this.updatePlayerNames();
            this.setupFirebaseListeners();

        } catch (error) {
            console.error('‚ùå Failed to join room:', error);
            this.showJoinError(error.message);
        }
    }
    
    showJoinError(message) {
        const joinBtn = document.getElementById('joinRoomBtn');
        const originalText = joinBtn.textContent;
        joinBtn.textContent = message;
        joinBtn.disabled = true;
        setTimeout(() => {
            joinBtn.textContent = originalText;
            joinBtn.disabled = false;
        }, 2000);
    }
    
    clearRoomCodeInput() {
        document.getElementById('roomCodeInput').value = '';
    }
    
    showNameError(inputElement, message) {
        const originalPlaceholder = inputElement.placeholder;
        inputElement.placeholder = message;
        inputElement.value = '';
        inputElement.classList.add('error');
        setTimeout(() => {
            inputElement.placeholder = originalPlaceholder;
            inputElement.classList.remove('error');
        }, 3000);
    }
    
    clearNameInputs() {
        document.getElementById('hostNameInput').value = '';
        document.getElementById('guestNameInput').value = '';
    }

    updatePlayerNames() {
        const choPlayerElement = document.getElementById('choPlayerName');
        const hanPlayerElement = document.getElementById('hanPlayerName');
        const choContainer = document.getElementById('choPlayerContainer');
        const hanContainer = document.getElementById('hanPlayerContainer');
        
        choPlayerElement.textContent = this.hostPlayerName || 'ÎåÄÍ∏∞Ï§ë...';
        hanPlayerElement.textContent = this.guestPlayerName || 'ÎåÄÍ∏∞Ï§ë...';
        
        if (this.isRoomHost || this.isRoomGuest) {
            choContainer.style.display = 'flex';
            hanContainer.style.display = 'flex';
        }
    }

    hidePlayerNames() {
        document.getElementById('choPlayerContainer').style.display = 'none';
        document.getElementById('hanPlayerContainer').style.display = 'none';
    }

    generatePlayerId() {
        return 'player_' + Math.random().toString(36).substr(2, 9);
    }

    initializeTheme() {
        if (this.isDarkMode) this.enableDarkMode();
        else this.enableLightMode();
    }

    toggleTheme() {
        this.isDarkMode = !this.isDarkMode;
        if (this.isDarkMode) this.enableDarkMode();
        else this.enableLightMode();
        localStorage.setItem('darkMode', this.isDarkMode.toString());
    }

    enableDarkMode() {
        document.getElementById('lightTheme').disabled = true;
        document.getElementById('darkTheme').disabled = false;
        document.querySelector('.theme-icon').textContent = '‚òÄÔ∏è';
    }

    enableLightMode() {
        document.getElementById('lightTheme').disabled = false;
        document.getElementById('darkTheme').disabled = true;
        document.querySelector('.theme-icon').textContent = 'üåô';
    }
}

document.addEventListener('DOMContentLoaded', () => {
    new JanggiGame();
});
